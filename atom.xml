<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咕咕鸡从不咕咕</title>
  <icon>https://www.gravatar.com/avatar/ad492a2d1d9ad5830bcdd06209040c71</icon>
  <subtitle>啥也不会</subtitle>
  <link href="https://www.ggjcbgg.icu/atom.xml" rel="self"/>
  
  <link href="https://www.ggjcbgg.icu/"/>
  <updated>2022-08-28T06:28:57.163Z</updated>
  <id>https://www.ggjcbgg.icu/</id>
  
  <author>
    <name>咕咕鸡从不咕咕</name>
    <email>1746644290@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式</title>
    <link href="https://www.ggjcbgg.icu/posts/a2d2.html"/>
    <id>https://www.ggjcbgg.icu/posts/a2d2.html</id>
    <published>2022-08-27T06:19:00.000Z</published>
    <updated>2022-08-28T06:28:57.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>总体来说设计模式分为三大类：</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>&#x3D;&#x3D;<strong>其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责</strong>&#x3D;&#x3D;</p><br><h2 id="七个面向对象设计原则"><a href="#七个面向对象设计原则" class="headerlink" title="七个面向对象设计原则"></a>七个面向对象设计原则</h2><ol><li><p>开闭原则：<br>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></li><li><p>单一职责原则：<br>一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。<br>如：DBUtil做连接数据库，CustomerDao做操作数据库中customer表，CustomerDataChart负责图表的生成和显示</p></li><li><p>里氏代换原则：<br>所有引用基类（父类）的地方必须能透明地使用其子类的对象。<br>&#x3D;&#x3D;<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常。尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>&#x3D;&#x3D;。</p></li><li><p>依赖倒转原则：<br>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。<br>&#x3D;&#x3D;将参数的改变放到配置文件中，就不会改变源代码，符合开闭原则。面向接口的编程&#x3D;&#x3D;</p><p><img src="/posts/a2d2.htm/bda79ba5d8f3014ad89f45f54970c67d.png" alt="截图"></p><blockquote><p>依赖倒转原则要求我们在程序代码中<strong>传递参数时或在关联关系中，尽量引用层次高的抽象层类</strong>，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，<strong>一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</strong></p></blockquote><blockquote><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而<strong>将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。</strong>构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p></blockquote><p>在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段</p></li><li><p>接口隔离原则：<br>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><blockquote><p>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干</p></blockquote></li><li><p>合成复用原则：<br>尽量使用对象组合，而不是继承来达到复用的目的。</p><blockquote><p>复用时要尽量使用组合&#x2F;聚合关系（关联关系），少用继承，降低类与类之间的耦合度。比如连接数据库的方法getConnection()封装在DBUtil类，mysql调用连接方法不是继承DBUtil类，而是调用DBUtil类的连接方法。</p></blockquote></li><li><p>迪米特原则：<br>一个软件实体应当尽可能少地与其他实体发生相互作用。</p><blockquote><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，<strong>迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</strong></p><br><p>  迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 当前对象本身(this)；</span><br><span class="line"></span><br><span class="line">(2) 以参数形式传入到当前对象方法中的对象；</span><br><span class="line"></span><br><span class="line">(3) 当前对象的成员对象；</span><br><span class="line"></span><br><span class="line">(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</span><br><span class="line"></span><br><span class="line">(5) 当前对象所创建的对象。</span><br></pre></td></tr></table></figure></blockquote></li></ol><br><h2 id="0-简单工厂模式"><a href="#0-简单工厂模式" class="headerlink" title="0.简单工厂模式"></a>0.简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><blockquote><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计.</p></blockquote><p><img src="/posts/a2d2.htm/1270515da88eab4f8c75369bb706d611.png" alt="截图"></p><p><strong>总结：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1. 主要优点</span><br><span class="line">  </span><br><span class="line">简单工厂模式的主要优点如下：</span><br><span class="line"></span><br><span class="line">(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</span><br><span class="line"></span><br><span class="line">(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</span><br><span class="line"></span><br><span class="line">(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</span><br><span class="line"></span><br><span class="line">  2. 主要缺点</span><br><span class="line"></span><br><span class="line">简单工厂模式的主要缺点如下：</span><br><span class="line"></span><br><span class="line">(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</span><br><span class="line"></span><br><span class="line">(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</span><br><span class="line"></span><br><span class="line">(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</span><br><span class="line"></span><br><span class="line">(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</span><br><span class="line"></span><br><span class="line"> 3. 适用场景</span><br><span class="line"></span><br><span class="line">在以下情况下可以考虑使用简单工厂模式：</span><br><span class="line"></span><br><span class="line">(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</span><br><span class="line"></span><br><span class="line">(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</span><br></pre></td></tr></table></figure><br><h2 id="1-工厂方法模式"><a href="#1-工厂方法模式" class="headerlink" title="1.工厂方法模式"></a>1.工厂方法模式</h2><p>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p><img src="/posts/a2d2.htm/42bdae37bbde11829f1bdf50708c465a.png" alt="截图" style="zoom:80%;"><p><img src="/posts/a2d2.htm/f89c577613be06bfb123a55972d6beb5.png" alt="截图"></p><br><blockquote><p>Logger接口充当抽象产品，其子类FileLogger和DatabaseLogger充当具体产品，LoggerFactory接口充当抽象工厂，其子类FileLoggerFactory和DatabaseLoggerFactory充当具体工厂。完整代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//日志记录器接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//数据库日志记录器：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;数据库日志记录。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//文件日志记录器：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;文件日志记录。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//日志记录器工厂接口：抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>XML格式的配置文件config.xml用于存储具体日志记录器工厂类类名：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!— config.xml --&gt;</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">className</span>&gt;</span>FileLoggerFactory<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  为了读取该配置文件并通过存储在其中的类名字符串反射生成对象，Sunny公司开发人员开发了一个名为XMLUtil的工具类，其详细代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具类XMLUtil.java</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line"><span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建DOM文档对象</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">Document doc;</span><br><span class="line">doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;config.xml&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取包含类名的文本节点</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName=classNode.getNodeValue();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class c=Class.forName(cName);</span><br><span class="line">      Object obj=c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了XMLUtil类后，可以对日志记录器的客户端代码进行修改，不再直接使用new关键字来创建具体的工厂类，而是将具体工厂类的类名存储在XML文件中，再通过XMLUtil类的静态工厂方法getBean()方法进行对象的实例化，代码修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">LoggerFactory factory;</span><br><span class="line">Logger logger;</span><br><span class="line">factory = (LoggerFactory)XMLUtil.getBean(); <span class="comment">//getBean()的返回类型为Object，需要进行强制类型转换</span></span><br><span class="line">logger = factory.createLogger();</span><br><span class="line">logger.writeLog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><br><p><strong>工厂方法模式总结</strong><br>      工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 主要优点</span><br><span class="line"></span><br><span class="line">     工厂方法模式的主要优点如下：</span><br><span class="line"></span><br><span class="line">     (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</span><br><span class="line"></span><br><span class="line">     (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</span><br><span class="line"></span><br><span class="line">     (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    2. 主要缺点</span><br><span class="line"></span><br><span class="line">   工厂方法模式的主要缺点如下：</span><br><span class="line"></span><br><span class="line">    (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</span><br><span class="line"></span><br><span class="line">    (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     3. 适用场景</span><br><span class="line"></span><br><span class="line">     在以下情况下可以考虑使用工厂方法模式：</span><br><span class="line"></span><br><span class="line">     (1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</span><br><span class="line"></span><br><span class="line">     (2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</span><br></pre></td></tr></table></figure><br><h2 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2.抽象工厂模式"></a>2.抽象工厂模式</h2><p>  抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p><blockquote><p>   在抽象工厂模式结构图中包含如下几个角色：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</span><br><span class="line"></span><br><span class="line">● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</span><br><span class="line"></span><br><span class="line">● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</span><br><span class="line"></span><br><span class="line">● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</span><br></pre></td></tr></table></figure></blockquote><img src="/posts/a2d2.htm/4178cba2a0df9defce0b9441bc0e6542.png" alt="截图" style="zoom:70%;"><br><p>SkinFactory接口充当抽象工厂，其子类SpringSkinFactory和SummerSkinFactory充当具体工厂，接口Button、TextField和ComboBox充当抽象产品，其子类SpringButton、SpringTextField、SpringComboBox和SummerButton、SummerTextField、SummerComboBox充当具体产品。完整代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在本实例中我们对代码进行了大量简化，实际使用时，界面组件的初始化代码较为复杂，还需要使用JDK中一些已有类，为了突出核心代码，在此只提供框架代码和演示输出。</span></span><br><span class="line"><span class="comment">//按钮接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring按钮类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示浅绿色按钮。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer按钮类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示浅蓝色按钮。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//文本框接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring文本框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示绿色边框文本框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer文本框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示蓝色边框文本框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//组合框接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring组合框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringComboBox</span> <span class="keyword">implements</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示绿色边框组合框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer组合框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerComboBox</span> <span class="keyword">implements</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示蓝色边框组合框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//界面皮肤工厂接口：抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> ComboBox <span class="title function_">createComboBox</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring皮肤工厂：具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringSkinFactory</span> <span class="keyword">implements</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringButton</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringTextField</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> ComboBox <span class="title function_">createComboBox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringComboBox</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer皮肤工厂：具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerSkinFactory</span> <span class="keyword">implements</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerButton</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerTextField</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> ComboBox <span class="title function_">createComboBox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerComboBox</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让系统具备良好的灵活性和可扩展性，我们引入了工具类XMLUtil和配置文件，其中，XMLUtil类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line"><span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文档对象</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">Document doc;</span><br><span class="line">doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;config.xml&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取包含类名的文本节点</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName=classNode.getNodeValue();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class c=Class.forName(cName);</span><br><span class="line">      Object obj=c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件config.xml中存储了具体工厂类的类名，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">className</span>&gt;</span>SpringSkinFactory<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  编写如下客户端测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">//使用抽象层定义</span></span><br><span class="line">SkinFactory factory;</span><br><span class="line">Button bt;</span><br><span class="line">TextField tf;</span><br><span class="line">ComboBox cb;</span><br><span class="line">factory = (SkinFactory)XMLUtil.getBean();</span><br><span class="line">bt = factory.createButton();</span><br><span class="line">tf = factory.createTextField();</span><br><span class="line">cb = factory.createComboBox();</span><br><span class="line">bt.display();</span><br><span class="line">tf.display();</span><br><span class="line">cb.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><blockquote><p><strong>抽象工厂模式总结</strong><br>       抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 主要优点</span><br><span class="line"></span><br><span class="line">抽象工厂模式的主要优点如下：</span><br><span class="line"></span><br><span class="line">(1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</span><br><span class="line"></span><br><span class="line">(2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</span><br><span class="line"></span><br><span class="line">(3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 主要缺点</span><br><span class="line"></span><br><span class="line">抽象工厂模式的主要缺点如下：</span><br><span class="line"></span><br><span class="line">增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 适用场景</span><br><span class="line"></span><br><span class="line">在以下情况下可以考虑使用抽象工厂模式：</span><br><span class="line"></span><br><span class="line">(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</span><br><span class="line"></span><br><span class="line">(2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</span><br><span class="line"></span><br><span class="line">(3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</span><br><span class="line"></span><br><span class="line">(4) 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</span><br></pre></td></tr></table></figure></blockquote><br><h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h2><p><strong>三种单例类的实现方式一共有三种，分别是：饿汉式单例、懒汉式单例以及IoDH</strong></p><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p><blockquote><p> 单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p></blockquote><img src="/posts/a2d2.htm/81af1c92f6acc101222c47dc6a6c1cf7.png" alt="截图" style="zoom:60%;"><blockquote><p> 单例模式结构图中只包含一个单例角色：</p><p>  ● Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p></blockquote><br><h3 id="1-饿汉式单例类"><a href="#1-饿汉式单例类" class="headerlink" title="1.饿汉式单例类"></a>1.饿汉式单例类</h3><p>  饿汉式单例类是实现起来最简单的单例类，由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>(); </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</p></blockquote><br><h3 id="2-懒汉式单例类与线程锁定"><a href="#2-懒汉式单例类与线程锁定" class="headerlink" title="2.懒汉式单例类与线程锁定"></a>2.懒汉式单例类与线程锁定</h3><p>懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该懒汉式单例类在getInstance()方法前面增加了关键字synchronized进行线程锁，以处理多个线程同时访问的问题。但是，上述代码虽然解决了线程安全问题，但是<strong>每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。</strong>&#x3D;&#x3D;因此需要进行进一步改进，在synchronized中再进行一次(instance  null)判断，这种方式称为<strong>双重检查锁</strong>定(Double-Check Locking)。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//第一重判断</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁定代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="comment">//第二重判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); <span class="comment">//创建单例实例</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。 </p></blockquote><br><h3 id="3-一种更好的单例实现方法（IoDH）"><a href="#3-一种更好的单例实现方法（IoDH）" class="headerlink" title="3.一种更好的单例实现方法（IoDH）"></a>3.一种更好的单例实现方法（IoDH）</h3><pre><code>    饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题，有没有一种方法，能够将两种单例的缺点都克服，而将两者的优点合二为一呢？答案是：Yes！下面我们来学习这种更好的被称之为Initialization Demand Holder (IoDH)的技术。</code></pre><ul><li><strong>在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，实现代码如下所示：</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialization on Demand Holder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HolderClass</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    Singleton s1, s2; </span><br><span class="line">            s1 = Singleton.getInstance();</span><br><span class="line">    s2 = Singleton.getInstance();</span><br><span class="line">    System.out.println(s1==s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 编译并运行上述代码，运行结果为：true，即创建的单例对象s1和s2为同一对象。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton(<strong>静态内部类和非静态内部类一样，都是在被调用时才会被加载</strong>)，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p></blockquote><br><p>** 通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式**（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p><br><p><strong>单例模式总结:</strong></p><blockquote><p>1.主要优点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式的主要优点如下：</span><br><span class="line"></span><br><span class="line">(1) 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</span><br><span class="line"></span><br><span class="line">(2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</span><br><span class="line"></span><br><span class="line">(3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</span><br></pre></td></tr></table></figure><p>2.主要缺点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式的主要缺点如下：</span><br><span class="line"></span><br><span class="line">(1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</span><br><span class="line"></span><br><span class="line">(2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</span><br><span class="line"></span><br><span class="line">(3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</span><br></pre></td></tr></table></figure><p>3.适用场景</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在以下情况下可以考虑使用单例模式：</span><br><span class="line"></span><br><span class="line">(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</span><br><span class="line"></span><br><span class="line">(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</span><br></pre></td></tr></table></figure></blockquote><br><h2 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h2><p>原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</p><blockquote><p>  原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p> ** 需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。**通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p></blockquote><img src="/posts/a2d2.htm/8cfe082a881cf48c4f6dc1c943b3694f.png" alt="截图" style="zoom:70%;"><br><p>  原型模式的核心在于如何实现克隆方法，下面将介绍两种在Java语言中常用的克隆实现方法：</p><h3 id="1-通用实现方法"><a href="#1-通用实现方法" class="headerlink" title="1.通用实现方法"></a>1.通用实现方法</h3><p>  通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。示意代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ConcretePrototype implements Prototype&#123;</span><br><span class="line"></span><br><span class="line">    private String  attr; //成员属性</span><br><span class="line">    </span><br><span class="line">    public void  setAttr(String attr)&#123;</span><br><span class="line">        this.attr = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String  getAttr()&#123;</span><br><span class="line">        return this.attr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Prototype  clone()&#123; //克隆方法</span><br><span class="line">       Prototype  prototype = new ConcretePrototype(); //创建新对象</span><br><span class="line">       prototype.setAttr(this.attr);</span><br><span class="line">       return prototype;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可作为原型模式的通用实现，它与编程语言特性无关，任何面向对象语言都可以使用这种形式来实现对原型的克隆。</p><br><h3 id="2-Java语言提供的clone-方法"><a href="#2-Java语言提供的clone-方法" class="headerlink" title="2.Java语言提供的clone()方法"></a>2.Java语言提供的clone()方法</h3><p>   学过Java语言的人都知道，<strong>所有的Java类都继承自java.lang.Object。事实上，Object类提供一个clone()方法，可以将一个Java对象复制一份。</strong>因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。</p><p>   需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ConcretePrototype implements  Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    public Prototype  clone()&#123;</span><br><span class="line">        Object object = null;</span><br><span class="line">        try &#123;</span><br><span class="line">　　　　　object = super.clone();</span><br><span class="line">　　    &#125; catch (CloneNotSupportedException exception) &#123;</span><br><span class="line">　　　　　System.err.println(&quot;Not support cloneable&quot;);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　return (Prototype )object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">客户端创建对象：</span><br><span class="line">Prototype obj1  = new ConcretePrototype();</span><br><span class="line">Prototype obj2  = obj1.clone();</span><br></pre></td></tr></table></figure><br><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般而言，Java语言中的clone()方法满足：</span><br></pre></td></tr></table></figure><p>(1) 对任何对象x，都有x.clone() !&#x3D; x，即克隆对象与原型对象不是同一个对象；</p><p>(2) 对任何对象x，都有x.clone().getClass() &#x3D;&#x3D; x.getClass()，即克隆对象与原型对象的类型一样；</p><p>(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</span><br></pre></td></tr></table></figure><p>(1) 在派生类中覆盖基类的clone()方法，并声明为public；</p><p>(2) 在派生类的clone()方法中，调用super.clone()；</p><p>(3)派生类需实现Cloneable接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</span><br></pre></td></tr></table></figure></blockquote><br><p><strong>有两种不同的克隆方法，浅克隆(ShallowClone)和深克隆(DeepClone)。在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</strong></p><br><h3 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1.浅克隆"></a>1.浅克隆</h3><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，<strong>在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量</strong>，<strong>而引用类型的成员对象并没有复制。</strong></p><p><img src="/posts/a2d2.htm/ed1b18ba3a48d0606073c7dc864175a0.png" alt="截图"></p><br><p>在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。</p><blockquote><p>如果是引用类型的属性被复制，用&#x3D;&#x3D;结果是true，因为是浅克隆是将引用对象的地址复制一份给克隆对象，还是同一个地址，所以相等。</p></blockquote><br><h3 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2.深克隆"></a>2.深克隆</h3><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制</p><p><img src="/posts/a2d2.htm/b3e25649883906dc3b77c754f3fd96de.png" alt="截图"></p><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.io.*;</span><br><span class="line"><span class="comment">//附件类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Attachment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">       <span class="keyword">private</span>  String name; <span class="comment">//附件名</span></span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">              <span class="built_in">this</span>.name  = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span>  String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  <span class="built_in">this</span>.name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;下载附件，文件名为&quot;</span> + name);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作周报类WeeklyLog不再使用Java自带的克隆机制，而是通过序列化来从头实现对象的深克隆，我们需要重新编写clone()方法，修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.io.*;</span><br><span class="line"><span class="comment">//工作周报类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">WeeklyLog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">       <span class="keyword">private</span>  Attachment attachment;</span><br><span class="line">       <span class="keyword">private</span>  String name;</span><br><span class="line">       <span class="keyword">private</span>  String date;</span><br><span class="line">       <span class="keyword">private</span>  String content;</span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">setAttachment</span><span class="params">(Attachment attachment)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.attachment  = attachment;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.name  = name;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">setDate</span><span class="params">(String date)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.date  = date;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.content  = content;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  Attachment <span class="title function_">getAttachment</span><span class="params">()</span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="built_in">this</span>.attachment);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="built_in">this</span>.name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  String <span class="title function_">getDate</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="built_in">this</span>.date);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span>  String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="built_in">this</span>.content);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用序列化技术实现深克隆</span></span><br><span class="line">       <span class="keyword">public</span> WeeklyLog <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span>  IOException, ClassNotFoundException, OptionalDataException&#123;</span><br><span class="line">              <span class="comment">//将对象写入流中</span></span><br><span class="line">              ByteArrayOutputStream bao=<span class="keyword">new</span>  <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">              ObjectOutputStream oos=<span class="keyword">new</span>  <span class="title class_">ObjectOutputStream</span>(bao);</span><br><span class="line">              oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">              <span class="comment">//将对象从流中取出</span></span><br><span class="line">              ByteArrayInputStream bis=<span class="keyword">new</span>  <span class="title class_">ByteArrayInputStream</span>(bao.toByteArray());</span><br><span class="line">              ObjectInputStream ois=<span class="keyword">new</span>  <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">              <span class="keyword">return</span>  (WeeklyLog)ois.readObject();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深克隆技术实现了原型对象和克隆对象的完全独立，对任意克隆对象的修改都不会给其他对象产生影响，是一种更为理想的克隆实现方式。</p><blockquote><p><strong>扩展</strong></p><p>Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</p></blockquote><br><h3 id="原型管理器的引入和实现"><a href="#原型管理器的引入和实现" class="headerlink" title="原型管理器的引入和实现"></a>原型管理器的引入和实现</h3><p>原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。<br><img src="/posts/a2d2.htm/b4faddffa70e5b874deb6148a62367f0.png" alt="截图" style="zoom:70%;"></p><br><p>实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">//抽象公文接口，也可定义为抽象类，提供clone()方法的实现，将业务方法声明为抽象方法</span><br><span class="line"></span><br><span class="line">interface OfficialDocument extends  Cloneable&#123;</span><br><span class="line">       public  OfficialDocument clone();</span><br><span class="line">       public  void display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可行性分析报告(Feasibility Analysis Report)类</span><br><span class="line">class FAR implements OfficialDocument&#123;</span><br><span class="line">       public  OfficialDocument clone()&#123;</span><br><span class="line">            OfficialDocument  far = null;</span><br><span class="line">            try&#123;</span><br><span class="line">                far  = (OfficialDocument)super.clone();</span><br><span class="line">            &#125;catch(CloneNotSupportedException  e)&#123;</span><br><span class="line">                System.out.println(&quot;不支持复制！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return  far;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public  void display()&#123;</span><br><span class="line">            System.out.println(&quot;《可行性分析报告》&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">//软件需求规格说明书(Software Requirements Specification)类</span><br><span class="line">class SRS implements OfficialDocument&#123;</span><br><span class="line">       public  OfficialDocument clone()&#123;</span><br><span class="line">            OfficialDocument  srs = null;</span><br><span class="line">            try&#123;</span><br><span class="line">                 srs  = (OfficialDocument)super.clone();</span><br><span class="line">            &#125;catch(CloneNotSupportedException  e)&#123; </span><br><span class="line">                System.out.println(&quot;不支持复制！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return  srs;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public  void display()&#123;</span><br><span class="line">              System.out.println(&quot;《软件需求规格说明书》&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原型管理器（使用饿汉式单例实现）</span><br><span class="line">class  PrototypeManager&#123;</span><br><span class="line">     //定义一个Hashtable，用于存储原型对象</span><br><span class="line">     private Hashtable ht=new Hashtable();</span><br><span class="line">     private static PrototypeManager pm =  new PrototypeManager();</span><br><span class="line">     //为Hashtable增加公文对象   </span><br><span class="line">     private  PrototypeManager()&#123;</span><br><span class="line">          ht.put(&quot;far&quot;,new  FAR());</span><br><span class="line">          ht.put(&quot;srs&quot;,new  SRS());               </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //增加新的公文对象</span><br><span class="line">     public void addOfficialDocument(String  key,OfficialDocument doc)&#123;</span><br><span class="line">         ht.put(key,doc);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //通过浅克隆获取新的公文对象</span><br><span class="line">     public OfficialDocument  getOfficialDocument(String key)&#123;</span><br><span class="line">          return  ((OfficialDocument)ht.get(key)).clone();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public static PrototypeManager  getPrototypeManager() &#123;</span><br><span class="line">          return pm;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在PrototypeManager中定义了一个Hashtable类型的集合对象，使用“键值对”来存储原型对象，客户端可以通过Key（如“far”或“srs”）来获取对应原型对象的克隆对象。PrototypeManager类提供了类似工厂方法的getOfficialDocument()方法用于返回一个克隆对象。在本实例代码中，我们将PrototypeManager设计为单例类，使用饿汉式单例实现，确保系统中有且仅有一个PrototypeManager对象，有利于节省系统资源，并可以更好地对原型管理器对象进行控制。</p></blockquote><br><br><p><strong>原型模式总结</strong><br>      原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用，下面对该模式的使用效果和适用情况进行简单的总结。</p><p><strong>1.主要优点</strong></p><p>  原型模式的主要优点如下：</p><p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p><p>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p><p>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p><p>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p><p><strong>2.主要缺点</strong></p><p> 原型模式的主要缺点如下：</p><p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p><p>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p><p><strong>3.适用场景</strong></p><p>在以下情况下可以考虑使用原型模式：</p><p>(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</p><p>(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</p><p>(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p><br><h2 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5.建造者模式"></a>5.建造者模式</h2><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p><blockquote><p>  建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p></blockquote><br><p>  建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图：</p><img src="/posts/a2d2.htm/4c69a147f272a0915b53c8020693df8e.png" alt="截图" style="zoom:70%;"><br><p><strong>建造者模式总结:</strong><br>      建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。</p><p>1.主要优点</p><blockquote><p>建造者模式的主要优点如下：</p><p>(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>(2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”</p><p>(3) 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p></blockquote><p>2.主要缺点</p><blockquote><p>建造者模式的主要缺点如下：</p><p>(1) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>(2) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</p></blockquote><p>3.适用场景</p><p>(1) 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p><p>(2) 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</p><p>(3) 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</p><p>(4) 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;p&gt;总体来说设计模式分为三大类：&lt;/p&gt;
&lt;p&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</summary>
      
    
    
    
    <category term="设计模式" scheme="https://www.ggjcbgg.icu/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.ggjcbgg.icu/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring5</title>
    <link href="https://www.ggjcbgg.icu/posts/58c6.html"/>
    <id>https://www.ggjcbgg.icu/posts/58c6.html</id>
    <published>2022-08-14T07:04:17.000Z</published>
    <updated>2022-08-28T06:23:10.604Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <font size="50">Spring5框架</font></div><h2 id="1-Spring概念-（视频链接）"><a href="#1-Spring概念-（视频链接）" class="headerlink" title="1.Spring概念 （视频链接）"></a>1.Spring概念 <a href="https://www.bilibili.com/video/BV1Vf4y127N5?p=4&spm_id_from=pageDriver">（视频链接）</a></h2><ol><li><p>spring是轻量级的开源的Java EE框架</p></li><li><p>Spring可以解决企业应用开发的复杂性</p></li><li><p>Spring有两个核心部分：IOC和Aop</p><blockquote><p><strong>(1)</strong>  IOC:控制反转，把创建对象过程交给Spring进行管理（<font color="red">不需要new创建对象</font>）</p><p><strong>（2）</strong> Aop：面向切面，不修改源代码进行功能增强</p></blockquote></li><li><p>Spring特点：</p><ul><li><p>方便解耦，简化开发</p></li><li><p>Aop编程的支持</p></li><li><p>方便程序测试</p></li><li><p>方便和其他框架进行整合</p></li><li><p>方便进行事务操作</p></li><li><p>降低API开发难度</p><hr></li></ul><h3 id="Spring5下载文件"><a href="#Spring5下载文件" class="headerlink" title="Spring5下载文件"></a>Spring5下载文件</h3><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913093926874.png" alt="image-20210913093926874"></p><p>Spring中每种有三个文件：</p><ul><li>第一个为架包</li><li>第二个-javadoc为文档</li><li>第三个-sources为源代码</li></ul><hr><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913094557402.png" alt="image-20210913094557402"></p></li></ol><ul><li>Core Container：核心部分</li><li>Beans、Core：对应IOC</li><li>Context：上下文</li><li>Expression：表达式</li></ul><h2 id="2-IOC容器"><a href="#2-IOC容器" class="headerlink" title="2.IOC容器"></a>2.IOC容器</h2><h5 id="IOC-概念和原理）"><a href="#IOC-概念和原理）" class="headerlink" title="IOC(概念和原理）"></a>IOC(概念和原理）</h5><blockquote><p>1、什么是IOC</p></blockquote><blockquote><blockquote><ul><li>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</li><li>使用IOC的目的：为了耦合度降低</li></ul></blockquote><p>2、IOC底层原理：</p><blockquote><p>xml解析、工厂模式、反射</p></blockquote><p>3、画图讲解IOC底层原理</p><p><font color="red"><b>调用另一个类的方法:</b></font></p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913120109189.png" alt="image-20210913120109189"></p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913120814177.png" alt="image-20210913120814177"></p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913162824150.png" alt="image-20210913162824150"></p></blockquote><h5 id="IOC接口"><a href="#IOC接口" class="headerlink" title="IOC接口"></a>IOC接口</h5><ol><li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p></li><li><p>Spring提供IOC容器实现两种方式：（两个接口）</p><blockquote><p>(1) BeanFactory : IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用</p><ul><li>加载配置文件的时候不会创建对象，在获取对象（使用）的时候才去创建对象</li></ul><p>(2) ApplicationContext : BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用</p><ul><li>加载配置文件的时候就会把配置文件对象进行创建</li></ul></blockquote></li><li><p>ApplicationContext接口有实现类</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913165428836.png" alt="image-20210913165428836"></p></li></ol><hr><h5 id="IOC操作Bean管理（概念）"><a href="#IOC操作Bean管理（概念）" class="headerlink" title="IOC操作Bean管理（概念）"></a>IOC操作Bean管理（概念）</h5><ol><li>什么是Bean管理<ul><li>Bean管理指的是两个操作</li><li>Spring创建对象</li><li>Spring注入属性</li></ul></li><li>Bean管理操作有两种方式<ul><li>基于xml配置文件方式实现</li><li>基于注解方式实现</li></ul></li></ol><h5 id="IOC操作Bean管理（基于xml方式）"><a href="#IOC操作Bean管理（基于xml方式）" class="headerlink" title="IOC操作Bean管理（基于xml方式）"></a>IOC操作Bean管理（基于xml方式）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置User对象创建--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.spring.test.User&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>（1）在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建</p><p>（2）在bean标签有很多属性，介绍常用的属性</p><blockquote><ul><li>id属性：唯一标识</li><li>class属性：类全路径（包类路径）</li></ul></blockquote><p>（3）创建对象的时候，默认也是执行无参数构造方法完成对象创建</p><ol start="2"><li><p>基于xml方式注入属性</p><blockquote><p>（1）DI：依赖注入，就是注入属性</p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913215126794.png" alt="image-20210913215126794" style="zoom:60%;"></blockquote></li><li><p>第一种注入方式：使用set方法进行注入</p><p>（1）创建类，定义属性和对应的set方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用set方法进行注入属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">//创建属性</span></span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="keyword">private</span> String bauthor;</span><br><span class="line">    <span class="comment">//创建属性对应的set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBname</span><span class="params">(String bname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBauthor</span><span class="params">(String bauthor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bauthor = bauthor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(2) 在spring配置文件配置对象创建，配置属性注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">2</span> set 方法注入属性--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;book&quot;</span> class=<span class="string">&quot;com.spring.test.Book&quot;</span>&gt;</span><br><span class="line">    &lt;!--使用property完成属性注入</span><br><span class="line">    name:类里面属性名称</span><br><span class="line">    value：向属性注入的值</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;bname&quot;</span> value=<span class="string">&quot;xiaoai&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;bauthor&quot;</span> value=<span class="string">&quot;xiao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种注入方式：使用有参数构造进行注入</p><p>(1) 创建类，定义属性，创建属性对应有参数构造方法</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210913231927303.png" alt="image-20210913231927303"></p><p>(2) 在spring配置文件中进行配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--有参数构造属性--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;orders&quot;</span> class=<span class="string">&quot;com.spring.test.Orders&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;电脑&quot;</span>&gt; &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;address&quot;</span> value=<span class="string">&quot;China&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210915194052986.png" alt="image-20210915194052986"></p></li></ol><hr><h5 id="IOC操作Bean管理（注入属性）"><a href="#IOC操作Bean管理（注入属性）" class="headerlink" title="IOC操作Bean管理（注入属性）"></a>IOC操作Bean管理（注入属性）</h5><ol><li><p>字面量</p><p>（1）null值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="literal">null</span>值--&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;address&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="literal">null</span>/&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>（2）属性值包含特殊符号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--属性值包含特殊符号</span><br><span class="line">   <span class="number">1</span> 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span><br><span class="line">   <span class="number">2</span> 把特殊符号内容写进CDATA 格式为：&lt;![CDATA[内容]]&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;address&quot;</span>&gt;</span><br><span class="line">    &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="注入属性-外部bean"><a href="#注入属性-外部bean" class="headerlink" title="注入属性-外部bean"></a>注入属性-外部bean</h5><blockquote><ul><li>创建两个类service类和dao类</li><li>在service调用dao里的方法</li><li>在spring配置文件中进行配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建UserDao类型属性，生成set方法</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add..........&quot;</span>);</span><br><span class="line">        userDao.update();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span> service和dao对象创建  接口不能<span class="keyword">new</span>对象，只能找接口的实现类--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.spring.test.service.UserService&quot;</span>&gt;</span><br><span class="line">        &lt;!--注入userDao对象</span><br><span class="line">        name属性值：类里面属性名称</span><br><span class="line">        ref属性：创建userDao对象bean标签的id值</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.spring.test.dao.UserDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>注入属性-内部bean</p><p>（1）一对多关系：部门和员工</p><p>一个部门有多个员工，一个员工属于一个部门</p><p>部门是一，员工是多</p><p>（2）在实体类之间表示一对多关系，员工表示所属的部门，使用对象类型属性进行表示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dname = dname;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">//员工属于某一个部门，使用对象形式表示</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在spring配置文件中进行配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--内部bean--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;emp&quot;</span> class=<span class="string">&quot;com.spring.test.bean.Emp&quot;</span>&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;ename&quot;</span> value=<span class="string">&quot;lucy&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置对象类型属性--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dept&quot;</span>&gt;</span><br><span class="line">        &lt;bean id=<span class="string">&quot;dept&quot;</span> class=<span class="string">&quot;com.spring.test.bean.Dept&quot;</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;dname&quot;</span> value=<span class="string">&quot;安保部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>注入属性-级联赋值</p><p>（1）第一种写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--级联赋值--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;emp&quot;</span> class=<span class="string">&quot;com.spring.test.bean.Emp&quot;</span>&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;ename&quot;</span> value=<span class="string">&quot;lucy&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;dept&quot;</span> class=<span class="string">&quot;com.spring.test.bean.Dept&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dname&quot;</span> value=<span class="string">&quot;财务部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第二种写法：</p><p>前提：dept要有get方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--级联赋值--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;emp&quot;</span> class=<span class="string">&quot;com.spring.test.bean.Emp&quot;</span>&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;ename&quot;</span> value=<span class="string">&quot;lucy&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dept.dname&quot;</span> value=<span class="string">&quot;技术部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;dept&quot;</span> class=<span class="string">&quot;com.spring.test.bean.Dept&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dname&quot;</span> value=<span class="string">&quot;财务部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><hr></li></ol><h5 id="IOC操作Bean管理（xml注入集合属性）"><a href="#IOC操作Bean管理（xml注入集合属性）" class="headerlink" title="IOC操作Bean管理（xml注入集合属性）"></a>IOC操作Bean管理（xml注入集合属性）</h5><ol><li>注入数组类型属性</li><li>注入List集合类型属性</li><li>注入Map集合类型属性</li></ol><p>（1）创建类，定义数组，list，map，set类型属性，生成对应set方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 数组类型属性</span></span><br><span class="line"><span class="keyword">private</span> String[] courses;</span><br><span class="line"><span class="comment">//2 list集合类型属性</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"><span class="comment">//3 map集合类型属性</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line"><span class="comment">//4 set集合类型属性</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sets = sets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maps = maps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.courses = courses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在sprin配置文件进行配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span> 集合类型属性注入--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;stu&quot;</span> class=<span class="string">&quot;com.spring5.collectiontype.Stu&quot;</span>&gt;</span><br><span class="line">    &lt;!--数组类型属性注入--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;courses&quot;</span>&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;java课程&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;数据库课程&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--list类型属性注入--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;李四&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--map类型属性注入--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maps&quot;</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">&quot;JAVA&quot;</span> value=<span class="string">&quot;java&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=<span class="string">&quot;PHP&quot;</span> value=<span class="string">&quot;php&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--set类型属性注入--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sets&quot;</span>&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;Mysql&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Redis&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>在集合里面设置对象类型值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--创建多个course对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;course1&quot;</span> class=<span class="string">&quot;com.spring5.collectiontype.Course&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;cname&quot;</span> value=<span class="string">&quot;Spring5框架&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;course2&quot;</span> class=<span class="string">&quot;com.spring5.collectiontype.Course&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;cname&quot;</span> value=<span class="string">&quot;MyBatis框架&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--注入list集合类型，值是对象--&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;courseList&quot;</span>&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;ref bean=<span class="string">&quot;course1&quot;</span>&gt;&lt;/ref&gt;</span><br><span class="line">        &lt;ref bean=<span class="string">&quot;course2&quot;</span>&gt;&lt;/ref&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>把集合注入的部分提取出来</p><p>（1）在spring配置文件中引入名称空间 util</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xmlns:util=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>（2）使用util标签完成list集合注入提取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span> 提取list集合类型属性注入--&gt;</span><br><span class="line">&lt;util:list id=<span class="string">&quot;bookList&quot;</span>&gt;</span><br><span class="line">    &lt;value&gt;语文&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;数学&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;英语&lt;/value&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br><span class="line">&lt;!--<span class="number">2</span> 提取list集合类型属性注入使用--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;book&quot;</span> class=<span class="string">&quot;com.spring5.collectiontype.Book&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;list&quot;</span> ref=<span class="string">&quot;bookList&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="IOC操作Bean管理（FactoryBean）"><a href="#IOC操作Bean管理（FactoryBean）" class="headerlink" title="IOC操作Bean管理（FactoryBean）"></a>IOC操作Bean管理（FactoryBean）</h5><ol><li><p>Spring有两种类型bean，一种是普通的bean，另外一种是工厂bean（FactoryBean）</p></li><li><p>普通bean：在配置文件中定义bean类型就是返回类型</p></li><li><p>工厂bean：在配置文件定义bean类型可以和返回类型不一样</p><blockquote><p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p><p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line">        course.setCname(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bean3.xml<span class="operator">:</span></span><br><span class="line"><span class="operator">&lt;</span>bean id<span class="operator">=</span><span class="string">&quot;myBean&quot;</span> <span class="built_in">class</span><span class="operator">=</span><span class="string">&quot;com.spring5.factorybean.MyBean&quot;</span><span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="operator">/</span>bean<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">    <span class="type">Course</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line">    System.out.println(myBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="IOC操作Bean管理（bean作用域）"><a href="#IOC操作Bean管理（bean作用域）" class="headerlink" title="IOC操作Bean管理（bean作用域）"></a>IOC操作Bean管理（bean作用域）</h5><ol><li><p>在Spring里面，设置创建bean实例是单实例还是多实例</p></li><li><p>在Spring里面，默认情况下，bean是单实例对象</p><p><img src="/posts/58c6.htm/桌面\Screenshot_20210917_185341.jpg" alt="Screenshot_20210917_185341"></p></li><li><p>如何设置单实例还是多实例</p><p>（1）在spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例</p><p>（2）scope属性值</p><p>第一个值 默认值：singletton 表示单实例对象</p><p>第二个值 prototype,表示是多实例对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;book&quot;</span> class=<span class="string">&quot;com.spring5.collectiontype.Book&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;list&quot;</span> ref=<span class="string">&quot;bookList&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/58c6.htm/笔记\image-20210917191941074.png" alt="image-20210917191941074"></p><p>（3）singleton和prototype区别</p><p>第一：singleten 单实例，prototype 多实例</p><p>第二：设置scope值是singleten或空的时候，加载spring配置文件时候就会创建单实例对象</p><p>​          设置scope值是prototype的时候，不是在加载spring配置文件时候创建对象，在调用getBean方法的时候创建多实例</p><h5 id="IOC操作Bean管理（bean生命周期）"><a href="#IOC操作Bean管理（bean生命周期）" class="headerlink" title="IOC操作Bean管理（bean生命周期）"></a>IOC操作Bean管理（bean生命周期）</h5><ol><li><p>生命周期：</p><p>（1）从对象创建到对象销毁的过程</p></li><li><p>bean生命周期：</p><p>（1）通过构造器创建bean实例（无参数构造）</p><p>（2）为bean的属性设置值和对其他bean引用（调用set方法）</p><p>（3）调用bean的初始化的方法（需要进行配置初始化的方法）</p><p>（4）bean可以使用了（对象已经获取到了）</p><p>（5）当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）</p></li><li><p>演示bean生命周期</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步 执行无参数构造创建bean实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用set方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;orders&quot;</span> class=<span class="string">&quot;com.spring5.bean.Orders&quot;</span> init-method=<span class="string">&quot;initMethod&quot;</span> destroy-method=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;手机&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean3</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);</span></span><br><span class="line">      <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">      <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">      System.out.println(<span class="string">&quot;第四步 获取创建bean实例对象&quot;</span>);</span><br><span class="line">      System.out.println(orders);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//手动让bean实例销毁</span></span><br><span class="line">      context.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210918114613583.png" alt="image-20210918114613583"></p></li><li><p>bean的后置处理器，生命周期有七步</p><p>（1）通过构造器创建bean实例（无参数构造）</p><p>（2）为bean的属性设置值和对其他bean引用（调用set方法）</p><p>（3）把bean实例传递bean后置处理器的方法 postProcessBeforeInitialization</p><p>（4）调用bean的初始化的方法（需要进行配置初始化的方法）</p><p>（5）把bean实例传递bean后置处理器的方法 postProcessAfterInitialization</p><p>（6）bean可以使用了（对象已经获取到了）</p><p>（7）当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）</p></li><li><p>演示添加后置处理器效果</p><p>（1）创建类，实现接口BeanPostProcessor，创建后置处理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置后置处理器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;myBeanPost&quot;</span> class=<span class="string">&quot;com.spring5.bean.MyBeanPost&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210919151426938.png" alt="image-20210919151426938"></p></li></ol><h5 id="IOC操作Bean管理（xml自动装配）"><a href="#IOC操作Bean管理（xml自动装配）" class="headerlink" title="IOC操作Bean管理（xml自动装配）"></a>IOC操作Bean管理（xml自动装配）</h5><ol><li><p>什么是自动装配</p><p>（1）根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值注入</p></li><li><p>演示自动装配过程</p><p>（1）根据属性名称自动注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--实现自动装配</span><br><span class="line">    bean标签属性autowire，配置自动装配</span><br><span class="line">    autowire属性常用两个值：</span><br><span class="line">        byName根据属性名称注入，注入值bean的id值和类属性名称一样  </span><br><span class="line">        byType根据属性类型注入</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;emp&quot;</span> class=<span class="string">&quot;com.spring5.autowire.Emp&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">    &lt;!--&lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dept&quot;</span> class=<span class="string">&quot;com.spring5.autowire.Dept&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>（2）根据属性类型自动注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--实现自动装配</span><br><span class="line">    bean标签属性autowire，配置自动装配</span><br><span class="line">    autowire属性常用两个值：</span><br><span class="line">        byName根据属性名称注入，注入值bean的id值和类属性名称一样  </span><br><span class="line">        byType根据属性类型注入</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;emp&quot;</span> class=<span class="string">&quot;com.spring5.autowire.Emp&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line">    &lt;!--&lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dept&quot;</span> class=<span class="string">&quot;com.spring5.autowire.Dept&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="IOC操作Bean管理（外部属性文件）"><a href="#IOC操作Bean管理（外部属性文件）" class="headerlink" title="IOC操作Bean管理（外部属性文件）"></a>IOC操作Bean管理（外部属性文件）</h5><ol><li><p>直接配置数据库信息</p><p>（1）配置德鲁伊连接池</p><p>（2）引入德鲁伊连接池依赖jar包</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--直接配置连接池--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;&lt;!--驱动名称--&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;&lt;!--数据库地址--&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;12345678&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入外部属性文件配置数据库连接池</p><p>（1）创建外部属性文件，properties格式文件，写数据库信息</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210920230259870.png" alt="image-20210920230259870"></p><p>（2）把外部properties属性文件引入到spring配置文件中</p><blockquote><p>引入context名称空间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在spring配置文件使用标签引入外部属性文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--引入外部的属性文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line"> &lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">     &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;&lt;!--驱动名称--&gt;&lt;/property&gt;</span><br><span class="line">     &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;&lt;!--数据库地址--&gt;&lt;/property&gt;</span><br><span class="line">     &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">     &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><h5 id="IOC操作Bean管理（基于注解方式）"><a href="#IOC操作Bean管理（基于注解方式）" class="headerlink" title="IOC操作Bean管理（基于注解方式）"></a><font color="red">IOC操作Bean管理（基于注解方式）</font></h5><ol><li><p>什么是注解</p><p>（1）注解是代码特殊标记，格式：@注解名称（属性名称&#x3D;属性值，属性名称&#x3D;属性值…..）</p><p>（2）使用注解，注解作用在类上面，方法上面，属性上面</p><p>（3）使用注解目的：简化xml配置</p></li><li><p>Spring针对Bean管理中创建对象提供注解</p><p>（1）@Component：是基础注解，表示一个 JavaBean 可以被注入到 Spring 容器中</p><p>（2）@Service：用在业务层，用来处理业务逻辑</p><p>（3）@Controller：用在表现层，对来自前端的请求进行转发处理与重定向</p><p>（4）@Repository：用在持久层，标注 DAO 类，表示这个类可以对数据库进行数据的读取或者写入</p><blockquote><p>上面四个注解功能是一样的，都可以用来创建bean实例</p></blockquote></li><li><p>基于注解方式实现对象创建</p><p>第一步：引入依赖<img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210921101116564.png" alt="image-20210921101116564"></p><p>第二步：开启组件扫描</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   &lt;!--开启组件扫描</span><br><span class="line">   <span class="number">1</span> 如果扫描多个包，多个包使用逗号隔开</span><br><span class="line">   <span class="number">2</span> 扫描包的上层目录 </span><br><span class="line">   --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.spring5&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>第三步：创建类，在类上面添加创建对象注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在注解里面value属性值可以省略不写，</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写 UserService--userService</span></span><br><span class="line"><span class="meta">@Service(value = &quot;userService&quot;)</span> </span><br><span class="line"><span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;com.service.UserService&quot;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启组件扫描细节配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--示例<span class="number">1</span></span><br><span class="line">use-<span class="keyword">default</span>-filters=<span class="string">&quot;false 表示现在不使用默认的filter，自己配置filter</span></span><br><span class="line"><span class="string">context:include-filter，设置扫描哪些内容</span></span><br><span class="line"><span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;context:component-scan base-package=&quot;</span>com.spring5<span class="string">&quot; use-default-filters=&quot;</span><span class="literal">false</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;context:include-filter type=&quot;</span>annotation<span class="string">&quot; expression=&quot;</span>org.springframework.stereotype.Controller<span class="string">&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;!--设置扫描注解为Controller的内容--&gt;</span></span><br><span class="line"><span class="string">&lt;/context:component-scan&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!--示例2</span></span><br><span class="line"><span class="string">下面配置扫描包所有内容</span></span><br><span class="line"><span class="string">context:exclude-filter:设置哪些内容不进行扫描</span></span><br><span class="line"><span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;context:component-scan base-package=&quot;</span>com.spring5<span class="string">&quot;jiy&gt;</span></span><br><span class="line"><span class="string">    &lt;context:exclude-filter type=&quot;</span>annotation<span class="string">&quot; expression=&quot;</span>org.springframework.stereotype.Controller<span class="string">&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;!--设置不扫描注解为Controller的内容--&gt;</span></span><br><span class="line"><span class="string">&lt;/context:component-scan&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于注解方式实现属性注入</p><p>(1) @Autowired：根据属性类型进行自动装配</p><blockquote><p>第一步：把service和dao对象创建，在service和dao类添加创建对象注释</p><p>第二步：在service注入dao对象，在service类添加dao类型属性，在属性上面使用注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//定义dao类型属性</span></span><br><span class="line"> <span class="comment">//不需要添加set方法</span></span><br><span class="line"> <span class="comment">// 添加注入属性注解</span></span><br><span class="line"> <span class="meta">@Autowired</span>  <span class="comment">//根据类型进行注入</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">     userDao.add();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>(2) @Qualifier：根据名称进行注入</p><blockquote><p>这个@Qualifier注解的使用，和上面@Autowired一起使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//定义dao类型属性</span></span><br><span class="line"> <span class="comment">//不需要添加set方法</span></span><br><span class="line"> <span class="comment">// 添加注入属性注解</span></span><br><span class="line"> <span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"> <span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span>  <span class="comment">//根据名称进行注入</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">     userDao.add();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(value = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;dao add....&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>(3) @Resource：可以根据类型注入，可以根据名称注入  (在javax拓展包中，不是spring提供的)</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Resource  //根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></blockquote><p>(4) @Value：注入普通类型属性</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;service add....&quot;</span>+name);</span><br><span class="line">     userDao.add();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210921170841353.png" alt="image-20210921170841353"></p></blockquote></li></ol><h5 id="IOC完全注解开发"><a href="#IOC完全注解开发" class="headerlink" title="IOC完全注解开发"></a>IOC完全注解开发</h5><p>（1）创建配置类，替代xml配置文件</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.spring5&quot;&#125;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>（2）编写测试类</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Annotation:注解</span></span><br><span class="line"><span class="comment">//Config:配置</span></span><br><span class="line"><span class="comment">//ApplicationContext:配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//加载配置类</span></span><br><span class="line"> <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"> UserService userService=context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"> System.out.println(userService);</span><br><span class="line"> userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-Aop"><a href="#3-Aop" class="headerlink" title="3.Aop"></a>3.Aop</h2><h5 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP(概念)"></a>AOP(概念)</h5><ol><li><p>什么是AOP</p><p>（1）面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</p><p>（2）通俗描述：不通过修改源代码方式，在主干功能里添加新功能</p><p>（3）使用登录的例子说明AOP</p><img src="file:///C:\Users\江流\Documents\Tencent Files\1746644290\Image\C2C\499DF78997C0A5E663C1263BA6405902.jpg" alt="img" style="zoom:80%;"></li></ol><h5 id="AOP（底层原理）"><a href="#AOP（底层原理）" class="headerlink" title="AOP（底层原理）"></a>AOP（底层原理）</h5><ol><li><p>AOP底层使用动态代理</p><p>（1）有两种情况动态代理</p><blockquote><p>第一种：有接口情况，使用JDK动态代理</p><ul><li>创建接口实现类代理对象，增强类的方法</li></ul><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210921195834206.png" alt="image-20210921195834206"></p><p>第二种：没有接口情况，使用CGLIB代理</p><ul><li>创建子类的代理对象，增强类的方法</li></ul><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210922194435974.png" alt="image-20210922194435974"></p></blockquote><hr></li></ol><h5 id="AOP（JDK动态代理）"><a href="#AOP（JDK动态代理）" class="headerlink" title="AOP（JDK动态代理）"></a>AOP（JDK动态代理）</h5><ol><li><p>使用JDK动态代理，使用Proxy类里面的方法创建代理对象</p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210922195132462.png" alt="image-20210922195132462" align="left"><p>（1）调用newProxyInstance方法</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210922195809368.png" alt="image-20210922195809368"></p><p>方法有三个参数：</p><p>第一参数，类加载器</p><p>第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</p><p>第三参数，实现这个接口InvocationHandler，创建代理对象，写增强的方法</p></li><li><p>JDK动态代理代码</p><p>（1）创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用Proxy类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring5;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"><span class="comment">//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//                return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dao.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line">    <span class="comment">//有参数构造传递</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot;:参数的传递....&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span>method.invoke(obj,args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行...&quot;</span>+obj);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210923203904005.png" alt="image-20210923203904005"></p></li></ol><h5 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP(术语)"></a>AOP(术语)</h5><ol><li><p>连接点 ：类里面哪些方法可以被增强，这些方法称为连接点</p></li><li><p>切入点 ：实际被真正增强的方法，称为切入点</p></li><li><p>通知（增强）</p><p>（1）实际增强的逻辑部分称为通知（增强）</p><p>（2）通知有多种类型</p><ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知：finally</li></ul></li><li><p>切面：是动作</p><p>（1）把通知应用到切入点过程</p><hr></li></ol><h5 id="AOP操作（准备）"><a href="#AOP操作（准备）" class="headerlink" title="AOP操作（准备）"></a>AOP操作（准备）</h5><ol><li><p>Spring框架一般都是基于AspectJ实现AOP操作</p><p>（1）什么是AspectJ</p><ul><li>AspectJ不是Spring组成部分，是独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</li></ul></li><li><p>基于AspectJ实现AOP操作</p><p>（1）基于xml配置文件实现</p><p>（2）基于注解方式实现（一般使用）</p></li><li><p>在项目工厂里面引入AOP相关依赖</p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210924131644127.png" alt="image-20210924131644127" style="zoom:80%;" align="left"></li><li><p>切入点表达式</p><p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强</p><p>（2）语法结构：</p><ul><li>execution([权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表]))</li></ul><blockquote><p>举例1：对com.dao.BookDao类里面的add进行增强</p><ul><li>execution(* com.dao.BookDao.add(…));</li><li>[权限修饰符]为*任意类型   [返回类型] 可不写  </li><li>[类全路径] 为com.dao.BookDao ：  [方法名称]为add  ：([参数列表])为(…)</li></ul><p>举例2：对com.dao.BookDao类里面的所有方法进行增强</p><ul><li>execution(* com.dao.BookDao.*(…));</li></ul><p>举例3：对com.dao包里面所有类和类里面方法进行增强</p><ul><li>execution(* com.dao.*. *(…));</li></ul></blockquote></li></ol><hr><h5 id="AOP操作（AspectJ注解）"><a href="#AOP操作（AspectJ注解）" class="headerlink" title="AOP操作（AspectJ注解）"></a>AOP操作（AspectJ注解）</h5><ol><li><p>创建类，在类里面定义方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建增强类（编写增强逻辑）</p><p>（1）在增强类里面创建方法，让不同方法代表不同通知类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行通知的配置</p><p>（1）在Spring配置文件中，开启注解扫描</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启注解扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.spring5.aopanno&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>（2）使用注解创建User和UserProxy对象</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210924142243587.png" alt="image-20210924142243587" style="zoom:80%;" align="left"><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210924142337049.png" alt="image-20210924142337049" style="zoom:80%;"></p><p>（3）在增强类什么添加注解@Aspect</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）在spring配置文件中开启生成代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--开启Aspect生成代理对象--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置不同类型的通知</p><p>（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终通知</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知（返回通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturn</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturn.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前.....&quot;</span>);</span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210924162427057.png" alt="image-20210924162427057" style="zoom:80%;"></li><li><p>相同的切入点抽取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相同的切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.spring5.aopanno.User.add())&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有多个增强类对同一个方法进行增强，设置增强类优先级</p><p>（1）在增强类上面添加注解@Order(数字类型的值)，数字类型值越小优先级越高</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h5 id="AOP操作（AspectJ配置文件）"><a href="#AOP操作（AspectJ配置文件）" class="headerlink" title="AOP操作（AspectJ配置文件）"></a>AOP操作（AspectJ配置文件）</h5><ol><li><p>创建两个类，增强类和被增强类，创建方法</p></li><li><p>在spring配置文件中创建两个类对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--创建对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;book&quot;</span> class=<span class="string">&quot;com.spring5.aopxml.Book&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookProxy&quot;</span> class=<span class="string">&quot;com.spring5.aopxml.BookProxy&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中配置切入点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置aop增强--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--切入点--&gt;</span><br><span class="line">    &lt;aop:pointcut id=<span class="string">&quot;p&quot;</span> expression=<span class="string">&quot;execution(* com.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span><br><span class="line">    &lt;!--配置切面 ref指的是增强类--&gt;</span><br><span class="line">    &lt;aop:aspect ref=<span class="string">&quot;bookProxy&quot;</span>&gt;</span><br><span class="line">        &lt;!--增强作用在具体的方法上 pointcut-ref指的是作用在哪个类即被增强类--&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">&quot;before&quot;</span> pointcut-ref=<span class="string">&quot;p&quot;</span>&gt;&lt;/aop:before&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="AOP完全注解开发"><a href="#AOP完全注解开发" class="headerlink" title="AOP完全注解开发"></a>AOP完全注解开发</h5><p>创建配置类，不需要创建xml配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring5.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com&quot;&#125;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span> <span class="comment">//开启Aspect生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JdbcTemplate"><a href="#4-JdbcTemplate" class="headerlink" title="4.JdbcTemplate"></a>4.JdbcTemplate</h2><h5 id="JdbcTemplate（概念和准备工作）"><a href="#JdbcTemplate（概念和准备工作）" class="headerlink" title="JdbcTemplate（概念和准备工作）"></a>JdbcTemplate（概念和准备工作）</h5><ol><li><p>什么是JdbcTemplate</p><ul><li>Spring框架对JDBC进行封装，使用JdbcTemplate方便实现数据库操作</li></ul></li><li><p>准备工作</p><ul><li><p>引入相关jar包</p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210925113817534.png" alt="image-20210925113817534" style="zoom: 80%;" align="left"></li><li><p>在spring配置文件配置数据库连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--数据库连接池--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;10250511biubiu&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置JdbcTemplate对象，注入DataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--JdbcTemplate对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;jdbcTemplate&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="line">    &lt;!--注入dataSource--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建service类，创建dao类，在dao注入JdbcTemplate对象</p><blockquote><p>配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--组件扫描--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.spring5&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>Service文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"> <span class="comment">//注入dao</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dao文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//注入JdbcTemplate</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h5 id="JdbcTemplate操作数据库（添加）"><a href="#JdbcTemplate操作数据库（添加）" class="headerlink" title="JdbcTemplate操作数据库（添加）"></a>JdbcTemplate操作数据库（添加）</h5><ol><li><p>对应数据库创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String ustatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUstatus</span><span class="params">(String ustatus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ustatus = ustatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUstatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ustatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写service和dao</p><ul><li><p>在dao进行数据库添加操作</p></li><li><p>调用JdbcTemplate对象里面update方法实现添加操作</p><ul><li><p>有两个参数</p></li><li><p>第一个参数：sql语句</p></li><li><p>第二个参数：可变参数。设置sql语句值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建sql语句</span></span><br><span class="line">        String sql=<span class="string">&quot;insert into t_book value(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="comment">//2 调用方法实现</span></span><br><span class="line">        Object[] args = &#123;book.getUserId(),book.getUsername(),book.getUstatus()&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql,args);</span><br><span class="line">        <span class="comment">//int update = jdbcTemplate.update(sql,book.getUserId(),book.getUsername(),book.getUstatus());</span></span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBook</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span>context.getBean(<span class="string">&quot;bookService&quot;</span>, BookService.class);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        book.setUsername(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        book.setUstatus(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        bookService.addBook(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li></ul></li></ul></li></ol><h5 id="JdbcTemplate操作数据库（修改和删除）"><a href="#JdbcTemplate操作数据库（修改和删除）" class="headerlink" title="JdbcTemplate操作数据库（修改和删除）"></a>JdbcTemplate操作数据库（修改和删除）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="comment">//1 创建sql语句</span></span><br><span class="line">    String sql=<span class="string">&quot;update t_book set username = ?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="comment">//2 调用方法实现</span></span><br><span class="line">    Object[] args = &#123;book.getUsername(),book.getUstatus(),book.getUserId()&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql,args);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> update= jdbcTemplate.update(sql,id);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JdbcTemplate操作数据库（查询返回某个值）"><a href="#JdbcTemplate操作数据库（查询返回某个值）" class="headerlink" title="JdbcTemplate操作数据库（查询返回某个值）"></a>JdbcTemplate操作数据库（查询返回某个值）</h5><ol><li><p>查询表里面有多少条记录，返回某个值</p></li><li><p>使用JdbcTemplate实现查询返回某个值代码</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210926103038444.png" alt="image-20210926103038444"></p><ul><li><p>有两个参数</p></li><li><p>第一个参数：sql语句</p></li><li><p>返回类型Class</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询表记录数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">selectCount</span><span class="params">()</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li></ul></li></ol><h5 id="JdbcTemplate操作数据库（查询返回对象）"><a href="#JdbcTemplate操作数据库（查询返回对象）" class="headerlink" title="JdbcTemplate操作数据库（查询返回对象）"></a>JdbcTemplate操作数据库（查询返回对象）</h5><ol><li><p>场景：查询图书详情</p></li><li><p>JdbcTemplate实现查询返回对象</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210926104758358.png" alt="image-20210926104758358"></p><ul><li><p>有三个参数</p></li><li><p>第一个参数：sql语句</p></li><li><p>第二个参数：RowMapper ：是接口，返回不同类型的数据，使用这个接口里面实现类完成数据封装</p></li><li><p>第三个参数：sql语句值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询返回对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">findBookInfo</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="JdbcTemplate操作数据库（查询返回集合）"><a href="#JdbcTemplate操作数据库（查询返回集合）" class="headerlink" title="JdbcTemplate操作数据库（查询返回集合）"></a>JdbcTemplate操作数据库（查询返回集合）</h5><ol><li><p>场景：查询图书列表分页…</p></li><li><p>调用JdbcTemplate方法实现查询返回集合</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210926111418111.png" alt="image-20210926111418111"></p><ul><li><p>有三个参数</p></li><li><p>第一个参数：sql语句</p></li><li><p>第二个参数：RowMapper ：是接口，返回不同类型的数据，使用这个接口里面实现类完成数据封装</p></li><li><p>第三个参数：sql语句值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    List&lt;Book&gt; bookList=jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class="line">    <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr></li></ol><h5 id="JdbcTemplate操作数据库（批量操作）"><a href="#JdbcTemplate操作数据库（批量操作）" class="headerlink" title="JdbcTemplate操作数据库（批量操作）"></a>JdbcTemplate操作数据库（批量操作）</h5><ol><li><p>批量操作：操作表里面多条记录</p></li><li><p>JdbcTemplate实现批量添加操作</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210926112243272.png" alt="image-20210926112243272"></p><ul><li><p>有两个参数</p></li><li><p>第一个参数：sql语句</p></li><li><p>第二个参数：List集合，添加多头记录数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAddBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book value(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量添加测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用批量添加</span></span><br><span class="line">bookService.batchAdd(batchArgs);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>JdbcTemplate实现批量修改操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;update t_book set username = ?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量修改</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;java12&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;java123&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;java134&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用方法实现批量修改</span></span><br><span class="line">bookService.batchUpdate(batchArgs);</span><br></pre></td></tr></table></figure></li><li><p>JdbcTemplate实现批量删除操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDeleteBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line"><span class="comment">//调用方法实现批量删除</span></span><br><span class="line">bookService.batchDelete(batchArgs);</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5.事务管理"></a>5.事务管理</h2><h5 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h5><ol><li><p>什么事务</p><p>（1）事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有</p><p>（2）典型场景：银行转账</p><p>​         lucy 转出 少钱</p><p>​         mary 收到转账 多钱</p></li><li><p>事务四个特性（ACID）</p><p>（1）原子性： </p><p>（2）一致性：</p><p>（3）隔离性：</p><p>（4）持久性：</p></li></ol><h5 id="事务操作（搭建事务操作环节）"><a href="#事务操作（搭建事务操作环节）" class="headerlink" title="事务操作（搭建事务操作环节）"></a>事务操作（搭建事务操作环节）</h5><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927091108527.png" alt="image-20210927091108527"></p><ol><li><p>创建数据库表，添加记录</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927091534733.png" alt="image-20210927091534733"></p></li><li><p>创建service，搭建dao，完成对象创建和注入关系</p><ul><li><p>service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在dao创建两个方法，多钱和少钱的方法，在service中创建方法（转账的方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lucy转账100给mary</span></span><br><span class="line">    <span class="comment">//多钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//少钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转账的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//lucy少100</span></span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line">        <span class="comment">//mary多100</span></span><br><span class="line">        userDao.addMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    UserService userService=context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.accountMoney();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码，如果正常执行是没有问题的，但是如果代码执行过程中出现异常，有问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转账的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//lucy少100</span></span><br><span class="line">    userDao.reduceMoney();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟异常</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mary多100</span></span><br><span class="line">    userDao.addMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>上面问题如何解决</p><ul><li>使用事务进行解决</li></ul></li><li><p>事务操作过程</p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927101720001.png" alt="image-20210927101720001" style="zoom:80%;"></li></ul></blockquote></li></ol><hr><h5 id="事务操作（Spring事务管理介绍）"><a href="#事务操作（Spring事务管理介绍）" class="headerlink" title="事务操作（Spring事务管理介绍）"></a>事务操作（Spring事务管理介绍）</h5><ol><li><p>事务添加到javaEE三层结构里面Service层（业务逻辑层）</p></li><li><p>在Spring进行事务管理操作</p><ul><li>有两种方式：编程式事务管理和声明式事务管理（一般使用）</li></ul></li><li><p>声明式事务管理</p><ul><li>基于注解方式（一般使用）</li><li>基于xml配置文件方式</li></ul></li><li><p>在Spring进行声明式事务管理，底层使用AOP原理</p><p><font color="red"><em><strong>事务管理，底层使用AOP原理</strong></em></font></p></li><li><p>Spring事务管理API</p><ul><li><p>提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927104045496.png" alt="image-20210927104045496"></p></li></ul></li></ol><h5 id="事务操作（注解声明式事务管理）"><a href="#事务操作（注解声明式事务管理）" class="headerlink" title="事务操作（注解声明式事务管理）"></a>事务操作（注解声明式事务管理）</h5><ol><li><p>在spring配置文件配置事务管理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--创建事务管理器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;transactionManager&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">    &lt;!--注入数据源--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中，开启事务注解</p><ul><li><p>在spring配置文件中引入名称空间tx</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xmlns:tx=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>开启事务注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--开启事务注解 transaction-manager指的是开启的事务管理器名称--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">&quot;transactionManager&quot;</span>&gt;&lt;/tx:annotation-driven&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在service类上面（获取service类里面方法上面）添加事务注解</p><ul><li><p>@Transactional，这个注解添加到类声明，也可以添加到方法上面</p></li><li><p>如果把这个注解添加到类上面，这个类里面所有的方法都添加事务</p></li><li><p>如果把这个注解添加到方法上面，则为这个方法添加事务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h5 id="事务操作（声明式事务管理参数配置）"><a href="#事务操作（声明式事务管理参数配置）" class="headerlink" title="事务操作（声明式事务管理参数配置）"></a>事务操作（声明式事务管理参数配置）</h5><ol><li><p>在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927163736787.png" alt="image-20210927163736787"></p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927163938362.png" alt="image-20210927163938362"></p></li><li><p>propagation：事务传播行为</p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927173542880.png" alt="image-20210927173542880" style="zoom:50%;"><ul><li><p>多事务方法直接进行调用，这个过程中事务是如何进行管理的</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927173927555.png" alt="image-20210927173927555"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span> <span class="comment">//默认情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ioslation：事务隔离级别</p><ul><li><p>事务由特性称为隔离性，多事务操作之间不会产生影响，不考虑隔离性产生很多问题</p></li><li><p>有三个读问题：脏读、不可重复读、虚（幻）读</p></li><li><p>脏读：一个未提交事务读取到另一个未提交事务的数据</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927175733413.png" alt="image-20210927175733413"></p></li><li><p>不可重复读：一个未提交事务读取到另一提交事务修改数据</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927180610796.png" alt="image-20210927180610796"></p><hr></li><li><p>虚（幻）读：一个未提交事务读取到另一提交事务添加数据</p><hr></li><li><p>解决：通过设置事务隔离级别，解决读问题</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20210927184441489.png" alt="image-20210927184441489"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)</span> <span class="comment">//默认情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>timeout：超时时间</p><ul><li>事务需要在一定时间内进行提交，如果不提交进行回滚</li><li>默认值是-1，设置时间以秒单位进行，-1为永不超时，无限大</li></ul></li><li><p>readOnly：是否只读</p><ul><li>读：查询操作，写：添加修改删除操作</li><li>readOnly默认值false，表示可以查询，可以添加修改删除操作</li><li>设置readOnly值是true，设置成true之后，只能查询</li></ul></li><li><p>rollbackFor：回滚</p><ul><li>设置出现哪些异常进行事务回滚</li></ul></li><li><p>noRollbackFor：不回滚</p><ul><li>设置出现哪些异常不进行事务回滚</li></ul></li></ol><hr><h5 id="事务操作（XML声明式事务管理）"><a href="#事务操作（XML声明式事务管理）" class="headerlink" title="事务操作（XML声明式事务管理）"></a>事务操作（XML声明式事务管理）</h5><ol><li><p>在spring配置文件中进行配置</p><ul><li><p>第一步：配置事务管理器</p></li><li><p>第二步：配置通知（增强的部分）</p></li><li><p>第三步：配置切入点和切面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xmlns:tx=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--组件扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.spring5&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--数据库连接池--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;10250511biubiu&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--JdbcTemplate对象--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;jdbcTemplate&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="line">        &lt;!--注入dataSource--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">1</span> 创建事务管理器--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transactionManager&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">        &lt;!--注入数据源--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">2</span> 配置通知--&gt;</span><br><span class="line">    &lt;tx:advice id=<span class="string">&quot;txadvice&quot;</span>&gt;</span><br><span class="line">        &lt;!--配置事务参数--&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!--指定哪种规则的方法上面添加事务--&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">&quot;accountMoney&quot;</span> propagation=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span><br><span class="line">            &lt;!--&lt;tx:method name=<span class="string">&quot;account*&quot;</span>/&gt;--&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">3</span> 配置切入点和切面--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--配置切入点--&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">&quot;pt&quot;</span> expression=<span class="string">&quot;execution(* com.spring5.service.UserService.*(..))&quot;</span>/&gt;</span><br><span class="line">        &lt;!--配置切面--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">&quot;txadvice&quot;</span> pointcut-ref=<span class="string">&quot;pt&quot;</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h5 id="事务操作（完全注解声明式事务管理）"><a href="#事务操作（完全注解声明式事务管理）" class="headerlink" title="事务操作（完全注解声明式事务管理）"></a>事务操作（完全注解声明式事务管理）</h5><ol><li><p>创建配置类，使用配置类代替xml文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com&quot;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;10250511biubiu&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建JdbcTemplate对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="comment">//到IOC容器中根据类型找到dataSource</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        <span class="comment">//注入dataSource</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">setDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager=<span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAccount2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(TxConfig.class);</span><br><span class="line">    UserService userService=context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.accountMoney();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-Spring5新特性"><a href="#6-Spring5新特性" class="headerlink" title="6.Spring5新特性"></a>6.Spring5新特性</h2><h5 id="Spring5框架新功能"><a href="#Spring5框架新功能" class="headerlink" title="Spring5框架新功能"></a>Spring5框架新功能</h5><ol><li><p>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除</p></li><li><p>Spring5.0框架自带了通用的日志封装</p><ul><li>Spring5已经移除Log4jConfigListener，官方建议使用Log4j2</li><li>Spring5框架整合Log4j2</li></ul><p>第一步引入jar包</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211008110733844.png" alt="image-20211008110733844"></p><p>第二步 创建log4j2.xml配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><br><span class="line">&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;</span><br><span class="line">&lt;configuration status=<span class="string">&quot;INFO&quot;</span>&gt;</span><br><span class="line">    &lt;!--先定义所有的appender--&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!--输出日志信息到控制台--&gt;</span><br><span class="line">        &lt;console name=<span class="string">&quot;Console&quot;</span> target=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br><span class="line">            &lt;!--控制日志输出的格式--&gt;</span><br><span class="line">            &lt;PatternLayout pattern=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br><span class="line">    &lt;/console&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line">    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span><br><span class="line">    &lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;root level=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;appender-ref ref=<span class="string">&quot;Console&quot;</span>/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>Spring5框架核心容器支持@Nullable注解</p><p>(1) @Nullable注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空</p><p>(2) 注解用在方法上面，方法返回值可以为空</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211012165555705.png" alt="image-20211012165555705"></p><p>(3) 注解使用在方法参数里面，方法参数可以为空</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211012165619276.png" alt="image-20211012165619276"></p><p>(4) 注解使用在属性说明，属性值可以为空</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211012170120905.png" alt="image-20211012170120905"></p></li><li><p>Spring5核心容器支持函数式风格GenericApplicationContext</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给spring进行管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAccount3</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//1 创建GenericApplicationContext对象</span></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">//2 调用context的方法对象注册</span></span><br><span class="line">    context.refresh(); <span class="comment">//清空内容</span></span><br><span class="line">    context.registerBean(<span class="string">&quot;user1&quot;</span>,User.class,() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    <span class="comment">//3 获取在spring注册对象</span></span><br><span class="line">    <span class="comment">//User user = (User)context.getBean(&quot;com.spring5.test.User&quot;);</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring5支持整合JUnit5</p><blockquote><p>JUnit4为了简化测试代码用注解的方式替代以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line">UserService userService=context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br></pre></td></tr></table></figure></blockquote><p>（1）整合JUnit4</p><p>第一步：引入Spring相关针对测试依赖</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211013194352797.png" alt="image-20211013194352797"></p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211013200129933.png" alt="image-20211013200129933"></p><p>第二步：创建测试类，使用注解方式完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span> <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest4</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）Spring5整合JUnit5</p><p>第一步：引入JUnit5的jar包</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211013201220618.png" alt="image-20211013201220618"></p><p>第二步：创建测试类，使用注解方式完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用一个复合注解替代上面两个注解完成整合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="SpringWebflux"><a href="#SpringWebflux" class="headerlink" title="SpringWebflux"></a>SpringWebflux</h5><ol><li><p>SpringWebflux介绍：</p><p><img src="/posts/58c6.htm/Users\江流\AppData\Roaming\Typora\typora-user-images\image-20211013202630000.png" alt="image-20211013202630000"></p></li><li><p>响应式编程</p></li><li><p>Webflux执行流程和核心API</p></li><li><p>SpringWebflux（基于注解编程模型）</p></li><li><p>SpringWebflux（基于函数式编程模型）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;div align=&quot;center&quot;&gt; &lt;font size=&quot;50&quot;&gt;Spring5框架&lt;/font&gt;&lt;/div&gt;


&lt;h2 id=&quot;1-Spring概念-（视频链接）&quot;&gt;&lt;a href=&quot;#1-Spring概念-（视频链接）&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="spring" scheme="https://www.ggjcbgg.icu/categories/spring/"/>
    
    
    <category term="spring" scheme="https://www.ggjcbgg.icu/tags/spring/"/>
    
  </entry>
  
</feed>
